{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"General A Redis Cluster Client Rationale The main asyncio redis library does not support redis cluster at this point. There is another library named aredis which has cluster support, but which has some small bugs for which pull requests existed, that were not merged until recently. Getting a redis client to work is not terribly hard, thanks to the design of redis, so I started this project and got it to work in a limited amount of time. Tools 2 tools come with this package, as subcommands of rcc. analyze-keyspace / will turn on redis keyspace notifications and tell you what your hot keys are. binpacking / will help reshard your cluster in an optimal way based on your usage. This will consume the output of the analyze-keyspace command","title":"General"},{"location":"#general","text":"A Redis Cluster Client","title":"General"},{"location":"#rationale","text":"The main asyncio redis library does not support redis cluster at this point. There is another library named aredis which has cluster support, but which has some small bugs for which pull requests existed, that were not merged until recently. Getting a redis client to work is not terribly hard, thanks to the design of redis, so I started this project and got it to work in a limited amount of time.","title":"Rationale"},{"location":"#tools","text":"2 tools come with this package, as subcommands of rcc. analyze-keyspace / will turn on redis keyspace notifications and tell you what your hot keys are. binpacking / will help reshard your cluster in an optimal way based on your usage. This will consume the output of the analyze-keyspace command","title":"Tools"},{"location":"CHANGELOG/","text":"Changelog All changes to this project will be documented in this file. [0.0.5] - 2020-02-04 missing sys import [0.0.4] - 2020-02-04 remove debug printf [0.0.2] - 2020-02-03 implement DEL command + add a very simple cli like redis-cli","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All changes to this project will be documented in this file.","title":"Changelog"},{"location":"CHANGELOG/#005-2020-02-04","text":"missing sys import","title":"[0.0.5] - 2020-02-04"},{"location":"CHANGELOG/#004-2020-02-04","text":"remove debug printf","title":"[0.0.4] - 2020-02-04"},{"location":"CHANGELOG/#002-2020-02-03","text":"implement DEL command + add a very simple cli like redis-cli","title":"[0.0.2] - 2020-02-03"},{"location":"resharding/","text":"Resharding Using rcc to reshard a redis cluster using keyspace notification rcc comes with 2 important tools, one for analyzing the keys access accross nodes, built on top of redis keyspace notifications (which in turns runs on top of redis PubSub). The instrumentation is done over a period of time to sample the key access patterns. A 'weights' file is created as part of this tool. That file is saved in the current working directory by default. It is a very simple csv file that show how often a key is accessed. Currently rcc only support tracking XADD redis commands. $ head weights.csv _pubsub::foo,50 _pubsub::bar,53 _pubsub::baz,7 _pubsub::buz,19 _pubsub::blah,940 _pubsub::blooh,20 _pubsub::xxx,552 _pubsub::yyy,571 _pubsub::zzz,92 _pubsub::foo,5035 The second tool is used to reshard a cluster, and migrate slots to node using the bin-packing algorithm. To feed this algorithm, weights are required. Generating redis cluster traffic. We use the cobra publish in batch mode command to send data to cobra , which internally send lots of XADD commands to our redis cluster. Cobra server started with: cobra run -r redis://localhost:11000 Cobra publishers: cobra publish --batch The redis cluster is started with: rcc make-cluster ; rcc has a convenience sub-command to generate config file for cluster (by default 3 masters and 3 replicas), and finally initialize the cluster. Keyspace access analysis before resharding rcc analyze-keyspace --redis_url redis://localhost:11000 --timeout 10 ... == Nodes == # each \u220e represents a count of 105. total 15515 127.0.0.1:11000 [ 6789] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11002 [ 4983] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11001 [ 3743] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e Resharding $ rcc reshard --redis_url redis://localhost:11000 file descriptors ulimit: 1024 resharding can be hungry, bump it with ulimit -n if needed == f3fa13802f339abb98ccb377e8a1a4eb957be987 / 127.0.0.1:11000 == migrated 0 slots Waiting for cluster view to be consistent... .== 8c67b776ab52ad756777866dcb8425cc866c71a3 / 127.0.0.1:11001 == migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrated 10 slots Waiting for cluster view to be consistent... ............== d50246e7e3914639759add181c71a2e3c879ed2f / 127.0.0.1:11002 == migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrated 11 slots Waiting for cluster view to be consistent... .....total migrated slots: 11 It roughtly looks like we took slots away from the first node, and gave them to the other two redis instances. Keyspace access analysis after resharding rcc analyze-keyspace --redis_url redis://localhost:11000 --timeout 10 ... == Nodes == # each \u220e represents a count of 79. total 15114 127.0.0.1:11002 [ 5087] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11000 [ 5040] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11001 [ 4987] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e","title":"Resharding"},{"location":"resharding/#resharding","text":"","title":"Resharding"},{"location":"resharding/#using-rcc-to-reshard-a-redis-cluster-using-keyspace-notification","text":"rcc comes with 2 important tools, one for analyzing the keys access accross nodes, built on top of redis keyspace notifications (which in turns runs on top of redis PubSub). The instrumentation is done over a period of time to sample the key access patterns. A 'weights' file is created as part of this tool. That file is saved in the current working directory by default. It is a very simple csv file that show how often a key is accessed. Currently rcc only support tracking XADD redis commands. $ head weights.csv _pubsub::foo,50 _pubsub::bar,53 _pubsub::baz,7 _pubsub::buz,19 _pubsub::blah,940 _pubsub::blooh,20 _pubsub::xxx,552 _pubsub::yyy,571 _pubsub::zzz,92 _pubsub::foo,5035 The second tool is used to reshard a cluster, and migrate slots to node using the bin-packing algorithm. To feed this algorithm, weights are required.","title":"Using rcc to reshard a redis cluster using keyspace notification"},{"location":"resharding/#generating-redis-cluster-traffic","text":"We use the cobra publish in batch mode command to send data to cobra , which internally send lots of XADD commands to our redis cluster. Cobra server started with: cobra run -r redis://localhost:11000 Cobra publishers: cobra publish --batch The redis cluster is started with: rcc make-cluster ; rcc has a convenience sub-command to generate config file for cluster (by default 3 masters and 3 replicas), and finally initialize the cluster.","title":"Generating redis cluster traffic."},{"location":"resharding/#keyspace-access-analysis-before-resharding","text":"rcc analyze-keyspace --redis_url redis://localhost:11000 --timeout 10 ... == Nodes == # each \u220e represents a count of 105. total 15515 127.0.0.1:11000 [ 6789] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11002 [ 4983] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11001 [ 3743] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e","title":"Keyspace access analysis before resharding"},{"location":"resharding/#resharding_1","text":"$ rcc reshard --redis_url redis://localhost:11000 file descriptors ulimit: 1024 resharding can be hungry, bump it with ulimit -n if needed == f3fa13802f339abb98ccb377e8a1a4eb957be987 / 127.0.0.1:11000 == migrated 0 slots Waiting for cluster view to be consistent... .== 8c67b776ab52ad756777866dcb8425cc866c71a3 / 127.0.0.1:11001 == migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrated 10 slots Waiting for cluster view to be consistent... ............== d50246e7e3914639759add181c71a2e3c879ed2f / 127.0.0.1:11002 == migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrating 1 keys migrated 11 slots Waiting for cluster view to be consistent... .....total migrated slots: 11 It roughtly looks like we took slots away from the first node, and gave them to the other two redis instances.","title":"Resharding"},{"location":"resharding/#keyspace-access-analysis-after-resharding","text":"rcc analyze-keyspace --redis_url redis://localhost:11000 --timeout 10 ... == Nodes == # each \u220e represents a count of 79. total 15114 127.0.0.1:11002 [ 5087] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11000 [ 5040] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e 127.0.0.1:11001 [ 4987] \u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e\u220e","title":"Keyspace access analysis after resharding"}]}